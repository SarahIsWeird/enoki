package blue.endless.enoki.markdown.styles.properties;

import blue.endless.enoki.markdown.styles.LayoutStyle;
import com.google.common.base.MoreObjects;
import net.minecraft.state.property.Property;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Objects;

import static java.util.Objects.requireNonNull;

/**
 * A StyleProperty represents a property in a {@link LayoutStyle}. It is similar in spirit
 * to block state {@link Property}s, but with less overhead and no requirement of knowing
 * the validity of a value on creation.
 * <p>
 * In particular, vanilla implementations of {@code Property} expect a list of all possible
 * values when creating the property. This is fine for booleans or enums, especially with
 * the vanilla use-case in mind, but unacceptable for concepts Enoki requires, such as
 * "positive integers only" or "a valid ARGB color".
 * <p>
 * The expectation is that any value set on a property is not {@code null}, and as such,
 * {@link #isCompatible(Object)} will return {@code false} if supplied with it. However,
 * since this class does not actually store any values, this is a contract and not a
 * steadfast requirement.
 * 
 * @param <T> The type this property represents. It is expected to be specified as
 *            {@link NotNull} for ease of use at call sites.
 */
public abstract class StyleProperty<T extends Comparable<T>> {
	@NotNull
	private final Class<T> typeClass;
	
	@NotNull
	private final String name;
	
	private final int hashCode;

	/**
	 * The super constructor.
	 * 
	 * @param typeClass The type class of the values this property can represent.
	 * @param name The name of the property
	 */
	protected StyleProperty(@NotNull Class<T> typeClass, @NotNull String name) {
		this.typeClass = requireNonNull(typeClass);
		this.name = requireNonNull(name);
		
		// We do this, because:
		// 1. StyleProperties are more or less exclusively used as keys, so it's important for it to be fast
		// 2. I'm copying from Property :^) That only computes it on first access, but that's unnecessary here.
		this.hashCode = Objects.hash(name, typeClass);
	}

	/**
	 * Checks if a value is allowed to be set for this property. If this functionality isn't required,
	 * it is acceptable to immediately return {@code true}.
	 * 
	 * @param value The value to check
	 * @return If the value is allowed to be set
	 */
	public abstract boolean isValid(@NotNull T value);

	/**
	 * Checks if an object is compatible with this property:
	 * <ul>
	 *     <li>It cannot be {@code null},</li>
	 *     <li>it has to be an instance of the correct type class, and</li>
	 *     <li>{@link #isValid} has to return {@code true} for it.</li>
	 * </ul>
	 * 
	 * @param object The object to check
	 * @return Whether the object is compatible
	 */
	public boolean isCompatible(@Nullable Object object) {
		// noinspection unchecked
		return this.typeClass.isInstance(object) && this.isValid((T) object);
	}

	/**
	 * Returns the name of this property.
	 * 
	 * @return The name of this property
	 */
	@NotNull
	public String getName() {
		return this.name;
	}

	@Override
	public String toString() {
		return MoreObjects.toStringHelper(this)
			.add("name", this.name)
			.add("typeClass", this.typeClass)
			.toString();
	}

	@Override
	public boolean equals(Object other) {
		// Overridden, since hashCode is overridden. It is auto-generated by IntelliJ.
		
		if (this == other) return true;
		if (!(other instanceof StyleProperty<?> otherProperty)) return false;
		
		return this.typeClass.equals(otherProperty.typeClass) && this.name.equals(otherProperty.name);
	}

	@Override
	public int hashCode() {
		return this.hashCode;
	}
}
